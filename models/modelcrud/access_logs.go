// Code generated by SQLBoiler 4.6.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package modelcrud

import (
	"net/http"
	"time"

	"github.com/calebhiebert/go-vue-template/api"
	"github.com/calebhiebert/go-vue-template/models"
	"github.com/gin-gonic/gin"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/types"
)

type APIAccessLog struct {
	ID   string `boil:"id" json:"id" toml:"id" yaml:"id"`
	Path string `boil:"path" json:"path" toml:"path" yaml:"path"`

	RequestBody *string `boil:"request_body" json:"request_body,omitempty" toml:"request_body" yaml:"request_body,omitempty"`

	RequestHeaders map[string]interface{} `boil:"request_headers" json:"request_headers,omitempty" toml:"request_headers" yaml:"request_headers,omitempty"`

	ResponseBody map[string]interface{} `boil:"response_body" json:"response_body" toml:"response_body" yaml:"response_body"`

	ResponseHeaders    map[string]interface{} `boil:"response_headers" json:"response_headers" toml:"response_headers" yaml:"response_headers"`
	ResponseCode       int                    `boil:"response_code" json:"response_code" toml:"response_code" yaml:"response_code"`
	ProcessingDuration int                    `boil:"processing_duration" json:"processing_duration" toml:"processing_duration" yaml:"processing_duration"`
	RequestMethod      string                 `boil:"request_method" json:"request_method" toml:"request_method" yaml:"request_method"`

	UserID    *string `boil:"user_id" json:"user_id,omitempty" toml:"user_id" yaml:"user_id,omitempty"`
	IPAddress string  `boil:"ip_address" json:"ip_address" toml:"ip_address" yaml:"ip_address"`

	CreatedAt *time.Time `boil:"created_at" json:"created_at,omitempty" toml:"created_at" yaml:"created_at,omitempty"`
}

type GetAccessLogsResponse struct {
	AccessLogs models.AccessLogSlice `json:"access_logs"`
	Total      int64                 `json:"total"`
	NextOffset int64                 `json:"next_offset"`
}

type APIGetAccessLogsResponse struct {
	AccessLogs []APIAccessLog `json:"access_logs"`
	Total      int64          `json:"total"`
	NextOffset int64          `json:"next_offset"`
}

// GetAccessLogByID godoc
// @Summary Gets a single AccessLog entity by their id
// @Produce json
// @Success 200 {object} APIGetAccessLogsResponse
// @Param id path string true "AccessLog id"
// @Router /crud/accessLogs/:id [get]
func (*GeneratedCrudController) GetAccessLogByID(c *gin.Context) {
	id := c.Param("id")

	if id == "" {
		api.NewAPIError("invalid-id", http.StatusBadRequest, "The provided id was invalid").Respond(c)
		return
	}

	AccessLog, err := models.AccessLogs(qm.Where("id = ?", id)).OneG(c.Request.Context())
	if err != nil {
		api.APIErrorFromErr(err).Respond(c)
		return
	}

	c.JSON(http.StatusOK, AccessLog)
}

// GetAccessLogs godoc
// @Summary Gets a list for all entities of the AccessLog type
// @Produce json
// @Success 200 {object} APIAccessLog
// @Router /crud/accessLogs [get]
func (*GeneratedCrudController) GetAccessLogs(c *gin.Context) {
	limit, offset := api.ExtractLimitOffset(c)

	count, err := models.AccessLogs().CountG(c.Request.Context())
	if err != nil {
		api.APIErrorFromErr(err).Respond(c)
		return
	}

	queryMods := []qm.QueryMod{
		qm.Limit(limit),
		qm.Offset(offset),
	}

	accessLogs, err := models.AccessLogs(queryMods...).AllG(c.Request.Context())
	if err != nil {
		api.APIErrorFromErr(err).Respond(c)
		return
	}

	if accessLogs == nil {
		accessLogs = models.AccessLogSlice{}
	}

	c.JSON(http.StatusOK, GetAccessLogsResponse{
		AccessLogs: accessLogs,
		Total:      count,
		NextOffset: int64(offset + limit),
	})
}

type APIUpdateAccessLogRequest struct {
	Path *string `boil:"path" json:"path" toml:"path" yaml:"path"`

	RequestBody *string `boil:"request_body" json:"request_body,omitempty" toml:"request_body" yaml:"request_body,omitempty"`

	RequestHeaders map[string]interface{} `boil:"request_headers" json:"request_headers,omitempty" toml:"request_headers" yaml:"request_headers,omitempty"`

	ResponseBody map[string]interface{} `boil:"response_body" json:"response_body" toml:"response_body" yaml:"response_body"`

	ResponseHeaders    map[string]interface{} `boil:"response_headers" json:"response_headers" toml:"response_headers" yaml:"response_headers"`
	ResponseCode       *int                   `boil:"response_code" json:"response_code" toml:"response_code" yaml:"response_code"`
	ProcessingDuration *int                   `boil:"processing_duration" json:"processing_duration" toml:"processing_duration" yaml:"processing_duration"`
	RequestMethod      *string                `boil:"request_method" json:"request_method" toml:"request_method" yaml:"request_method"`

	UserID    *string `boil:"user_id" json:"user_id,omitempty" toml:"user_id" yaml:"user_id,omitempty"`
	IPAddress *string `boil:"ip_address" json:"ip_address" toml:"ip_address" yaml:"ip_address"`
}

type UpdateAccessLogRequest struct {
	Path               *string      `boil:"path" json:"path,omitempty" toml:"path" yaml:"path"`
	RequestBody        *null.String `boil:"request_body" json:"request_body,omitempty" toml:"request_body" yaml:"request_body,omitempty"`
	RequestHeaders     *null.JSON   `boil:"request_headers" json:"request_headers,omitempty" toml:"request_headers" yaml:"request_headers,omitempty"`
	ResponseBody       *types.JSON  `boil:"response_body" json:"response_body,omitempty" toml:"response_body" yaml:"response_body"`
	ResponseHeaders    *types.JSON  `boil:"response_headers" json:"response_headers,omitempty" toml:"response_headers" yaml:"response_headers"`
	ResponseCode       *int         `boil:"response_code" json:"response_code,omitempty" toml:"response_code" yaml:"response_code"`
	ProcessingDuration *int         `boil:"processing_duration" json:"processing_duration,omitempty" toml:"processing_duration" yaml:"processing_duration"`
	RequestMethod      *string      `boil:"request_method" json:"request_method,omitempty" toml:"request_method" yaml:"request_method"`
	UserID             *null.String `boil:"user_id" json:"user_id,omitempty" toml:"user_id" yaml:"user_id,omitempty"`
	IPAddress          *string      `boil:"ip_address" json:"ip_address,omitempty" toml:"ip_address" yaml:"ip_address"`
}

// UpdateAccessLogByID godoc
// @Summary Updates a single AccessLog entity based on their id
// @Produce json
// @Accept json
// @Param req body APIUpdateAccessLogRequest true "Update parameters"
// @Param id path string true "AccessLog id"
// @Success 200 {object} APIAccessLog
// @Router /crud/accessLogs/:id [put]
func (*GeneratedCrudController) UpdateAccessLogByID(c *gin.Context) {
	id := c.Param("id")

	if id == "" {
		api.NewAPIError("invalid-id", http.StatusBadRequest, "The provided id was invalid").Respond(c)
		return
	}

	var updateReq UpdateAccessLogRequest

	err := c.BindJSON(&updateReq)
	if err != nil {
		api.APIErrorFromErr(err).Respond(c)
		return
	}

	existingAccessLog, err := models.AccessLogs(qm.Where("id = ?", id), qm.For("UPDATE")).OneG(c.Request.Context())
	if err != nil {
		api.APIErrorFromErr(err).Respond(c)
		return
	}

	if updateReq.Path != nil {
		existingAccessLog.Path = *updateReq.Path
	}

	if updateReq.RequestBody != nil {
		existingAccessLog.RequestBody = *updateReq.RequestBody
	}

	if updateReq.RequestHeaders != nil {
		existingAccessLog.RequestHeaders = *updateReq.RequestHeaders
	}

	if updateReq.ResponseBody != nil {
		existingAccessLog.ResponseBody = *updateReq.ResponseBody
	}

	if updateReq.ResponseHeaders != nil {
		existingAccessLog.ResponseHeaders = *updateReq.ResponseHeaders
	}

	if updateReq.ResponseCode != nil {
		existingAccessLog.ResponseCode = *updateReq.ResponseCode
	}

	if updateReq.ProcessingDuration != nil {
		existingAccessLog.ProcessingDuration = *updateReq.ProcessingDuration
	}

	if updateReq.RequestMethod != nil {
		existingAccessLog.RequestMethod = *updateReq.RequestMethod
	}

	if updateReq.UserID != nil {
		existingAccessLog.UserID = *updateReq.UserID
	}

	if updateReq.IPAddress != nil {
		existingAccessLog.IPAddress = *updateReq.IPAddress
	}

	_, err = existingAccessLog.UpdateG(c.Request.Context(), boil.Infer())
	if err != nil {
		api.APIErrorFromErr(err).Respond(c)
		return
	}

	c.JSON(http.StatusOK, existingAccessLog)
}

// DeleteAccessLogByID godoc
// @Summary Soft deletes a single AccessLog entity based on their id
// @Produce json
// @Success 200 {object} APIAccessLog
// @Param id path string true "AccessLog id"
// @Router /crud/accessLogs/:id [delete]
func (*GeneratedCrudController) DeleteAccessLogByID(c *gin.Context) {
	id := c.Param("id")

	if id == "" {
		api.NewAPIError("invalid-id", http.StatusBadRequest, "The provided id was invalid").Respond(c)
		return
	}

	existingAccessLog, err := models.AccessLogs(qm.Where("id = ?", id)).OneG(c.Request.Context())
	if err != nil {
		api.APIErrorFromErr(err).Respond(c)
		return
	}

	_, err = existingAccessLog.DeleteG(c.Request.Context())
	if err != nil {
		api.APIErrorFromErr(err).Respond(c)
		return
	}

	c.JSON(http.StatusOK, existingAccessLog)
}

func (gcc *GeneratedCrudController) RegisterAccessLogs(rg *gin.RouterGroup) {
	rg.GET("/accessLogs/:id", gcc.GetAccessLogByID)
	rg.GET("/accessLogs", gcc.GetAccessLogs)
	rg.PUT("/accessLogs/:id", gcc.UpdateAccessLogByID)
	rg.DELETE("/accessLogs/:id", gcc.DeleteAccessLogByID)
}

var AccessLogsAdmin = api.AdminModel{
	Name:          "AccessLogs",
	CanSoftDelete: false,
	URLName:       "accessLogs",
	DataName:      "access_logs",
	Fields: []*api.AdminModelField{&api.AdminModelField{
		ID:       "id",
		Name:     "ID",
		Nullable: false,
		Config:   api.NewDefaultAdminModelFieldConfig(),
		Type:     "string",
	}, &api.AdminModelField{
		ID:       "path",
		Name:     "Path",
		Nullable: false,
		Config:   api.NewDefaultAdminModelFieldConfig(),
		Type:     "string",
	}, &api.AdminModelField{
		ID:       "request_body",
		Name:     "RequestBody",
		Nullable: true,
		Config:   api.NewDefaultAdminModelFieldConfig(),
		Type:     "string",
	}, &api.AdminModelField{
		ID:       "request_headers",
		Name:     "RequestHeaders",
		Nullable: true,
		Config:   api.NewDefaultAdminModelFieldConfig(),
		Type:     "json",
	}, &api.AdminModelField{
		ID:       "response_body",
		Name:     "ResponseBody",
		Nullable: false,
		Config:   api.NewDefaultAdminModelFieldConfig(),
		Type:     "json",
	}, &api.AdminModelField{
		ID:       "response_headers",
		Name:     "ResponseHeaders",
		Nullable: false,
		Config:   api.NewDefaultAdminModelFieldConfig(),
		Type:     "json",
	}, &api.AdminModelField{
		ID:       "response_code",
		Name:     "ResponseCode",
		Nullable: false,
		Config:   api.NewDefaultAdminModelFieldConfig(),
		Type:     "int",
	}, &api.AdminModelField{
		ID:       "processing_duration",
		Name:     "ProcessingDuration",
		Nullable: false,
		Config:   api.NewDefaultAdminModelFieldConfig(),
		Type:     "int",
	}, &api.AdminModelField{
		ID:       "request_method",
		Name:     "RequestMethod",
		Nullable: false,
		Config:   api.NewDefaultAdminModelFieldConfig(),
		Type:     "string",
	}, &api.AdminModelField{
		ID:       "user_id",
		Name:     "UserID",
		Nullable: true,
		Config:   api.NewDefaultAdminModelFieldConfig(),
		Type:     "string",
	}, &api.AdminModelField{
		ID:       "ip_address",
		Name:     "IPAddress",
		Nullable: false,
		Config:   api.NewDefaultAdminModelFieldConfig(),
		Type:     "string",
	}, &api.AdminModelField{
		ID:       "created_at",
		Name:     "CreatedAt",
		Nullable: true,
		Config:   api.NewDefaultAdminModelFieldConfig(),
		Type:     "time",
	},
	},
}

type AccessLogsModelConfigType struct {
	ID                 api.AdminModelFieldConfig
	Path               api.AdminModelFieldConfig
	RequestBody        api.AdminModelFieldConfig
	RequestHeaders     api.AdminModelFieldConfig
	ResponseBody       api.AdminModelFieldConfig
	ResponseHeaders    api.AdminModelFieldConfig
	ResponseCode       api.AdminModelFieldConfig
	ProcessingDuration api.AdminModelFieldConfig
	RequestMethod      api.AdminModelFieldConfig
	UserID             api.AdminModelFieldConfig
	IPAddress          api.AdminModelFieldConfig
	CreatedAt          api.AdminModelFieldConfig
}

var AccessLogsModelConfig = AccessLogsModelConfigType{
	ID: api.AdminModelFieldConfig{
		ShowOnGraph: true,
	},
	Path: api.AdminModelFieldConfig{
		ShowOnGraph: true,
	},
	RequestBody: api.AdminModelFieldConfig{
		ShowOnGraph: true,
	},
	RequestHeaders: api.AdminModelFieldConfig{
		ShowOnGraph: true,
	},
	ResponseBody: api.AdminModelFieldConfig{
		ShowOnGraph: true,
	},
	ResponseHeaders: api.AdminModelFieldConfig{
		ShowOnGraph: true,
	},
	ResponseCode: api.AdminModelFieldConfig{
		ShowOnGraph: true,
	},
	ProcessingDuration: api.AdminModelFieldConfig{
		ShowOnGraph: true,
	},
	RequestMethod: api.AdminModelFieldConfig{
		ShowOnGraph: true,
	},
	UserID: api.AdminModelFieldConfig{
		ShowOnGraph: true,
	},
	IPAddress: api.AdminModelFieldConfig{
		ShowOnGraph: true,
	},
	CreatedAt: api.AdminModelFieldConfig{
		ShowOnGraph: true,
	},
}

func (c AccessLogsModelConfigType) Apply() {
	AccessLogsAdmin.Fields[0].Config = c.ID
	AccessLogsAdmin.Fields[1].Config = c.Path
	AccessLogsAdmin.Fields[2].Config = c.RequestBody
	AccessLogsAdmin.Fields[3].Config = c.RequestHeaders
	AccessLogsAdmin.Fields[4].Config = c.ResponseBody
	AccessLogsAdmin.Fields[5].Config = c.ResponseHeaders
	AccessLogsAdmin.Fields[6].Config = c.ResponseCode
	AccessLogsAdmin.Fields[7].Config = c.ProcessingDuration
	AccessLogsAdmin.Fields[8].Config = c.RequestMethod
	AccessLogsAdmin.Fields[9].Config = c.UserID
	AccessLogsAdmin.Fields[10].Config = c.IPAddress
	AccessLogsAdmin.Fields[11].Config = c.CreatedAt

}
