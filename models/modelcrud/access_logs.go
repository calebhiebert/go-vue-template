// Code generated by SQLBoiler 4.6.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package modelcrud

import (
	"net/http"
	"strings"
	"time"

	"github.com/calebhiebert/go-vue-template/api"
	"github.com/calebhiebert/go-vue-template/models"
	"github.com/gin-gonic/gin"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/types"
)

type APIAccessLog struct {
	ID   string `boil:"id" json:"id" toml:"id" yaml:"id"`
	Path string `boil:"path" json:"path" toml:"path" yaml:"path"`

	RequestBody *string `boil:"request_body" json:"request_body,omitempty" toml:"request_body" yaml:"request_body,omitempty"`

	RequestHeaders map[string]interface{} `boil:"request_headers" json:"request_headers,omitempty" toml:"request_headers" yaml:"request_headers,omitempty"`

	ResponseBody map[string]interface{} `boil:"response_body" json:"response_body" toml:"response_body" yaml:"response_body"`

	ResponseHeaders    map[string]interface{} `boil:"response_headers" json:"response_headers" toml:"response_headers" yaml:"response_headers"`
	ResponseCode       int                    `boil:"response_code" json:"response_code" toml:"response_code" yaml:"response_code"`
	ProcessingDuration int                    `boil:"processing_duration" json:"processing_duration" toml:"processing_duration" yaml:"processing_duration"`
	RequestMethod      string                 `boil:"request_method" json:"request_method" toml:"request_method" yaml:"request_method"`

	UserID    *string `boil:"user_id" json:"user_id,omitempty" toml:"user_id" yaml:"user_id,omitempty"`
	IPAddress string  `boil:"ip_address" json:"ip_address" toml:"ip_address" yaml:"ip_address"`

	CreatedAt *time.Time `boil:"created_at" json:"created_at,omitempty" toml:"created_at" yaml:"created_at,omitempty"`
}

type GetAccessLogsResponse struct {
	AccessLogs models.AccessLogSlice `json:"access_logs"`
	Total      int64                 `json:"total"`
	NextOffset int64                 `json:"next_offset"`
}

type APIGetAccessLogsResponse struct {
	AccessLogs []APIAccessLog `json:"access_logs"`
	Total      int64          `json:"total"`
	NextOffset int64          `json:"next_offset"`
}

// GetAccessLogByID godoc
// @Summary Gets a single AccessLog entity by their id
// @Produce json
// @Success 200 {object} APIGetAccessLogsResponse
// @Param id path string true "AccessLog id"
// @Router /crud/accessLogs/:id [get]
func (*GeneratedCrudController) GetAccessLogByID(c *gin.Context) {
	id := c.Param("id")

	if id == "" {
		api.NewAPIError("invalid-id", http.StatusBadRequest, "The provided id was invalid").Respond(c)
		return
	}

	AccessLog, err := models.AccessLogs(qm.Where("id = ?", id)).OneG(c.Request.Context())
	if err != nil {
		api.APIErrorFromErr(err).Respond(c)
		return
	}

	c.JSON(http.StatusOK, AccessLog)
}

// GetAccessLogs godoc
// @Summary Gets a list for all entities of the AccessLog type
// @Produce json
// @Success 200 {object} APIAccessLog
// @Param sort.id query string false "Sort by id. Value should be ASC or DESC. eg: ?sort.created_at=DESC"
// @Param sort.path query string false "Sort by path. Value should be ASC or DESC. eg: ?sort.created_at=DESC"
// @Param sort.request_body query string false "Sort by request_body. Value should be ASC or DESC. eg: ?sort.created_at=DESC"
// @Param sort.request_headers query string false "Sort by request_headers. Value should be ASC or DESC. eg: ?sort.created_at=DESC"
// @Param sort.response_body query string false "Sort by response_body. Value should be ASC or DESC. eg: ?sort.created_at=DESC"
// @Param sort.response_headers query string false "Sort by response_headers. Value should be ASC or DESC. eg: ?sort.created_at=DESC"
// @Param sort.response_code query string false "Sort by response_code. Value should be ASC or DESC. eg: ?sort.created_at=DESC"
// @Param sort.processing_duration query string false "Sort by processing_duration. Value should be ASC or DESC. eg: ?sort.created_at=DESC"
// @Param sort.request_method query string false "Sort by request_method. Value should be ASC or DESC. eg: ?sort.created_at=DESC"
// @Param sort.user_id query string false "Sort by user_id. Value should be ASC or DESC. eg: ?sort.created_at=DESC"
// @Param sort.ip_address query string false "Sort by ip_address. Value should be ASC or DESC. eg: ?sort.created_at=DESC"
// @Param sort.created_at query string false "Sort by created_at. Value should be ASC or DESC. eg: ?sort.created_at=DESC"
// @Router /crud/accessLogs [get]
func (*GeneratedCrudController) GetAccessLogs(c *gin.Context) {
	limit, offset := api.ExtractLimitOffset(c)

	count, err := models.AccessLogs().CountG(c.Request.Context())
	if err != nil {
		api.APIErrorFromErr(err).Respond(c)
		return
	}

	queryMods := []qm.QueryMod{
		qm.Limit(limit),
		qm.Offset(offset),
	}

	var orderBy []string

	for q, v := range c.Request.URL.Query() {
		sortDirection := "ASC"

		if v[0] == "DESC" || v[0] == "desc" {
			sortDirection = "DESC"
		}

		switch q {
		case "sort.id":
			orderBy = append(orderBy, "id "+sortDirection)
		case "sort.path":
			orderBy = append(orderBy, "path "+sortDirection)
		case "sort.request_body":
			orderBy = append(orderBy, "request_body "+sortDirection)
		case "sort.request_headers":
			orderBy = append(orderBy, "request_headers "+sortDirection)
		case "sort.response_body":
			orderBy = append(orderBy, "response_body "+sortDirection)
		case "sort.response_headers":
			orderBy = append(orderBy, "response_headers "+sortDirection)
		case "sort.response_code":
			orderBy = append(orderBy, "response_code "+sortDirection)
		case "sort.processing_duration":
			orderBy = append(orderBy, "processing_duration "+sortDirection)
		case "sort.request_method":
			orderBy = append(orderBy, "request_method "+sortDirection)
		case "sort.user_id":
			orderBy = append(orderBy, "user_id "+sortDirection)
		case "sort.ip_address":
			orderBy = append(orderBy, "ip_address "+sortDirection)
		case "sort.created_at":
			orderBy = append(orderBy, "created_at "+sortDirection)
		}
	}

	if len(orderBy) > 0 {
		queryMods = append(queryMods, qm.OrderBy(strings.Join(orderBy, ", ")))
	} else {
		queryMods = append(queryMods, qm.OrderBy("created_at DESC"))
	}

	accessLogs, err := models.AccessLogs(queryMods...).AllG(c.Request.Context())
	if err != nil {
		api.APIErrorFromErr(err).Respond(c)
		return
	}

	if accessLogs == nil {
		accessLogs = models.AccessLogSlice{}
	}

	c.JSON(http.StatusOK, GetAccessLogsResponse{
		AccessLogs: accessLogs,
		Total:      count,
		NextOffset: int64(offset + limit),
	})
}

type APIUpdateAccessLogRequest struct {
	Path *string `boil:"path" json:"path" toml:"path" yaml:"path"`

	RequestBody *string `boil:"request_body" json:"request_body,omitempty" toml:"request_body" yaml:"request_body,omitempty"`

	RequestHeaders map[string]interface{} `boil:"request_headers" json:"request_headers,omitempty" toml:"request_headers" yaml:"request_headers,omitempty"`

	ResponseBody map[string]interface{} `boil:"response_body" json:"response_body" toml:"response_body" yaml:"response_body"`

	ResponseHeaders    map[string]interface{} `boil:"response_headers" json:"response_headers" toml:"response_headers" yaml:"response_headers"`
	ResponseCode       *int                   `boil:"response_code" json:"response_code" toml:"response_code" yaml:"response_code"`
	ProcessingDuration *int                   `boil:"processing_duration" json:"processing_duration" toml:"processing_duration" yaml:"processing_duration"`
	RequestMethod      *string                `boil:"request_method" json:"request_method" toml:"request_method" yaml:"request_method"`

	UserID    *string `boil:"user_id" json:"user_id,omitempty" toml:"user_id" yaml:"user_id,omitempty"`
	IPAddress *string `boil:"ip_address" json:"ip_address" toml:"ip_address" yaml:"ip_address"`
}

type UpdateAccessLogRequest struct {
	Path               *string      `boil:"path" json:"path,omitempty" toml:"path" yaml:"path"`
	RequestBody        *null.String `boil:"request_body" json:"request_body,omitempty" toml:"request_body" yaml:"request_body,omitempty"`
	RequestHeaders     *null.JSON   `boil:"request_headers" json:"request_headers,omitempty" toml:"request_headers" yaml:"request_headers,omitempty"`
	ResponseBody       *types.JSON  `boil:"response_body" json:"response_body,omitempty" toml:"response_body" yaml:"response_body"`
	ResponseHeaders    *types.JSON  `boil:"response_headers" json:"response_headers,omitempty" toml:"response_headers" yaml:"response_headers"`
	ResponseCode       *int         `boil:"response_code" json:"response_code,omitempty" toml:"response_code" yaml:"response_code"`
	ProcessingDuration *int         `boil:"processing_duration" json:"processing_duration,omitempty" toml:"processing_duration" yaml:"processing_duration"`
	RequestMethod      *string      `boil:"request_method" json:"request_method,omitempty" toml:"request_method" yaml:"request_method"`
	UserID             *null.String `boil:"user_id" json:"user_id,omitempty" toml:"user_id" yaml:"user_id,omitempty"`
	IPAddress          *string      `boil:"ip_address" json:"ip_address,omitempty" toml:"ip_address" yaml:"ip_address"`
}

// UpdateAccessLogByID godoc
// @Summary Updates a single AccessLog entity based on their id
// @Produce json
// @Accept json
// @Param req body APIUpdateAccessLogRequest true "Update parameters"
// @Param id path string true "AccessLog id"
// @Success 200 {object} APIAccessLog
// @Router /crud/accessLogs/:id [put]
func (*GeneratedCrudController) UpdateAccessLogByID(c *gin.Context) {
	id := c.Param("id")

	if id == "" {
		api.NewAPIError("invalid-id", http.StatusBadRequest, "The provided id was invalid").Respond(c)
		return
	}

	var updateReq UpdateAccessLogRequest

	err := c.BindJSON(&updateReq)
	if err != nil {
		api.APIErrorFromErr(err).Respond(c)
		return
	}

	existingAccessLog, err := models.AccessLogs(qm.Where("id = ?", id), qm.For("UPDATE")).OneG(c.Request.Context())
	if err != nil {
		api.APIErrorFromErr(err).Respond(c)
		return
	}

	if updateReq.Path != nil {
		existingAccessLog.Path = *updateReq.Path
	}

	if updateReq.RequestBody != nil {
		existingAccessLog.RequestBody = *updateReq.RequestBody
	}

	if updateReq.RequestHeaders != nil {
		existingAccessLog.RequestHeaders = *updateReq.RequestHeaders
	}

	if updateReq.ResponseBody != nil {
		existingAccessLog.ResponseBody = *updateReq.ResponseBody
	}

	if updateReq.ResponseHeaders != nil {
		existingAccessLog.ResponseHeaders = *updateReq.ResponseHeaders
	}

	if updateReq.ResponseCode != nil {
		existingAccessLog.ResponseCode = *updateReq.ResponseCode
	}

	if updateReq.ProcessingDuration != nil {
		existingAccessLog.ProcessingDuration = *updateReq.ProcessingDuration
	}

	if updateReq.RequestMethod != nil {
		existingAccessLog.RequestMethod = *updateReq.RequestMethod
	}

	if updateReq.UserID != nil {
		existingAccessLog.UserID = *updateReq.UserID
	}

	if updateReq.IPAddress != nil {
		existingAccessLog.IPAddress = *updateReq.IPAddress
	}

	_, err = existingAccessLog.UpdateG(c.Request.Context(), boil.Infer())
	if err != nil {
		api.APIErrorFromErr(err).Respond(c)
		return
	}

	c.JSON(http.StatusOK, existingAccessLog)
}

// DeleteAccessLogByID godoc
// @Summary Soft deletes a single AccessLog entity based on their id
// @Produce json
// @Success 200 {object} APIAccessLog
// @Param id path string true "AccessLog id"
// @Router /crud/accessLogs/:id [delete]
func (*GeneratedCrudController) DeleteAccessLogByID(c *gin.Context) {
	id := c.Param("id")

	if id == "" {
		api.NewAPIError("invalid-id", http.StatusBadRequest, "The provided id was invalid").Respond(c)
		return
	}

	existingAccessLog, err := models.AccessLogs(qm.Where("id = ?", id)).OneG(c.Request.Context())
	if err != nil {
		api.APIErrorFromErr(err).Respond(c)
		return
	}

	_, err = existingAccessLog.DeleteG(c.Request.Context())
	if err != nil {
		api.APIErrorFromErr(err).Respond(c)
		return
	}

	c.JSON(http.StatusOK, existingAccessLog)
}

// BulkDeleteAccessLogsByIDs godoc
// @Summary Soft deletes a range of accessLogs by their ids
// @Produce json
// @Success 200 {object} DeletedCount
// @Param req body IDList true "List of ids to delete"
// @Param hardDelete query string false "Hard delete accessLog"
// @Router /crud/accessLogs [delete]
func (*GeneratedCrudController) BulkDeleteAccessLogsByIDs(c *gin.Context) {

	var ids IDList

	err := c.BindJSON(&ids)
	if err != nil {
		api.APIErrorFromErr(err).Respond(c)
		return
	}

	var idInterface []interface{}

	for _, id := range ids.IDs {
		idInterface = append(idInterface, id)
	}

	deleted, err := models.AccessLogs(qm.WhereIn("id IN ?", idInterface...)).DeleteAllG(c.Request.Context())
	if err != nil {
		api.APIErrorFromErr(err).Respond(c)
		return
	}

	c.JSON(http.StatusOK, DeletedCount{DeletedCount: int(deleted)})
}

func (gcc *GeneratedCrudController) RegisterAccessLogs(rg *gin.RouterGroup) {
	rg.GET("/accessLogs/:id", gcc.GetAccessLogByID)
	rg.GET("/accessLogs", gcc.GetAccessLogs)
	rg.PUT("/accessLogs/:id", gcc.UpdateAccessLogByID)
	rg.DELETE("/accessLogs/:id", gcc.DeleteAccessLogByID)
	rg.DELETE("/accessLogs", gcc.BulkDeleteAccessLogsByIDs)
}

var AccessLogsAdmin = api.AdminModel{
	Name:          "AccessLogs",
	CanSoftDelete: false,
	URLName:       "accessLogs",
	DataName:      "access_logs",
	Fields: []*api.AdminModelField{
		&api.AdminModelField{
			ID:       "id",
			Name:     "ID",
			Nullable: false,
			Editable: false,
			Config: api.AdminModelFieldConfig{
				ShowOnGraph: true,
				Editable:    true,
				IsEmail:     false,
			},
			Type: "string",
		},
		&api.AdminModelField{
			ID:       "path",
			Name:     "Path",
			Nullable: false,
			Editable: true,
			Config: api.AdminModelFieldConfig{
				ShowOnGraph: true,
				Editable:    true,
				IsEmail:     false,
			},
			Type: "string",
		},
		&api.AdminModelField{
			ID:       "request_body",
			Name:     "RequestBody",
			Nullable: true,
			Editable: true,
			Config: api.AdminModelFieldConfig{
				ShowOnGraph: true,
				Editable:    true,
				IsEmail:     false,
			},
			Type: "string",
		},
		&api.AdminModelField{
			ID:       "request_headers",
			Name:     "RequestHeaders",
			Nullable: true,
			Editable: true,
			Config: api.AdminModelFieldConfig{
				ShowOnGraph: true,
				Editable:    true,
				IsEmail:     false,
			},
			Type: "json",
		},
		&api.AdminModelField{
			ID:       "response_body",
			Name:     "ResponseBody",
			Nullable: false,
			Editable: true,
			Config: api.AdminModelFieldConfig{
				ShowOnGraph: true,
				Editable:    true,
				IsEmail:     false,
			},
			Type: "json",
		},
		&api.AdminModelField{
			ID:       "response_headers",
			Name:     "ResponseHeaders",
			Nullable: false,
			Editable: true,
			Config: api.AdminModelFieldConfig{
				ShowOnGraph: true,
				Editable:    true,
				IsEmail:     false,
			},
			Type: "json",
		},
		&api.AdminModelField{
			ID:       "response_code",
			Name:     "ResponseCode",
			Nullable: false,
			Editable: true,
			Config: api.AdminModelFieldConfig{
				ShowOnGraph: true,
				Editable:    true,
				IsEmail:     false,
			},
			Type: "int",
		},
		&api.AdminModelField{
			ID:       "processing_duration",
			Name:     "ProcessingDuration",
			Nullable: false,
			Editable: true,
			Config: api.AdminModelFieldConfig{
				ShowOnGraph: true,
				Editable:    true,
				IsEmail:     false,
			},
			Type: "int",
		},
		&api.AdminModelField{
			ID:       "request_method",
			Name:     "RequestMethod",
			Nullable: false,
			Editable: true,
			Config: api.AdminModelFieldConfig{
				ShowOnGraph: true,
				Editable:    true,
				IsEmail:     false,
			},
			Type: "string",
		},
		&api.AdminModelField{
			ID:       "user_id",
			Name:     "UserID",
			Nullable: true,
			Editable: true,
			Config: api.AdminModelFieldConfig{
				ShowOnGraph: true,
				Editable:    true,
				IsEmail:     false,
			},
			Type: "string",
		},
		&api.AdminModelField{
			ID:       "ip_address",
			Name:     "IPAddress",
			Nullable: false,
			Editable: true,
			Config: api.AdminModelFieldConfig{
				ShowOnGraph: true,
				Editable:    true,
				IsEmail:     false,
			},
			Type: "string",
		},
		&api.AdminModelField{
			ID:       "created_at",
			Name:     "CreatedAt",
			Nullable: true,
			Editable: false,
			Config: api.AdminModelFieldConfig{
				ShowOnGraph: true,
				Editable:    true,
				IsEmail:     false,
			},
			Type: "time",
		},
	},
}

type AccessLogsModelConfigType struct {
	ID api.AdminModelFieldConfig

	Path api.AdminModelFieldConfig

	RequestBody api.AdminModelFieldConfig

	RequestHeaders api.AdminModelFieldConfig

	ResponseBody api.AdminModelFieldConfig

	ResponseHeaders api.AdminModelFieldConfig

	ResponseCode api.AdminModelFieldConfig

	ProcessingDuration api.AdminModelFieldConfig

	RequestMethod api.AdminModelFieldConfig

	UserID api.AdminModelFieldConfig

	IPAddress api.AdminModelFieldConfig

	CreatedAt api.AdminModelFieldConfig
}

var AccessLogsModelConfig = AccessLogsModelConfigType{

	ID: api.AdminModelFieldConfig{
		ShowOnGraph: true,
		Editable:    true,
		IsEmail:     false,
	},
	Path: api.AdminModelFieldConfig{
		ShowOnGraph: true,
		Editable:    true,
		IsEmail:     false,
	},
	RequestBody: api.AdminModelFieldConfig{
		ShowOnGraph: true,
		Editable:    true,
		IsEmail:     false,
	},
	RequestHeaders: api.AdminModelFieldConfig{
		ShowOnGraph: true,
		Editable:    true,
		IsEmail:     false,
	},
	ResponseBody: api.AdminModelFieldConfig{
		ShowOnGraph: true,
		Editable:    true,
		IsEmail:     false,
	},
	ResponseHeaders: api.AdminModelFieldConfig{
		ShowOnGraph: true,
		Editable:    true,
		IsEmail:     false,
	},
	ResponseCode: api.AdminModelFieldConfig{
		ShowOnGraph: true,
		Editable:    true,
		IsEmail:     false,
	},
	ProcessingDuration: api.AdminModelFieldConfig{
		ShowOnGraph: true,
		Editable:    true,
		IsEmail:     false,
	},
	RequestMethod: api.AdminModelFieldConfig{
		ShowOnGraph: true,
		Editable:    true,
		IsEmail:     false,
	},
	UserID: api.AdminModelFieldConfig{
		ShowOnGraph: true,
		Editable:    true,
		IsEmail:     false,
	},
	IPAddress: api.AdminModelFieldConfig{
		ShowOnGraph: true,
		Editable:    true,
		IsEmail:     false,
	},
	CreatedAt: api.AdminModelFieldConfig{
		ShowOnGraph: true,
		Editable:    true,
		IsEmail:     false,
	},
}

func (c AccessLogsModelConfigType) Apply() {

	AccessLogsAdmin.Fields[0].Config = c.ID

	AccessLogsAdmin.Fields[1].Config = c.Path

	AccessLogsAdmin.Fields[2].Config = c.RequestBody

	AccessLogsAdmin.Fields[3].Config = c.RequestHeaders

	AccessLogsAdmin.Fields[4].Config = c.ResponseBody

	AccessLogsAdmin.Fields[5].Config = c.ResponseHeaders

	AccessLogsAdmin.Fields[6].Config = c.ResponseCode

	AccessLogsAdmin.Fields[7].Config = c.ProcessingDuration

	AccessLogsAdmin.Fields[8].Config = c.RequestMethod

	AccessLogsAdmin.Fields[9].Config = c.UserID

	AccessLogsAdmin.Fields[10].Config = c.IPAddress

	AccessLogsAdmin.Fields[11].Config = c.CreatedAt

}
