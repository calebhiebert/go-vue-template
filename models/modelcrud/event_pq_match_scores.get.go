// Code generated by SQLBoiler 4.6.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package modelcrud

import (
	"fmt"
	"net/http"
	"strings"

	"github.com/calebhiebert/go-vue-template/api"
	"github.com/calebhiebert/go-vue-template/models"
	"github.com/gin-gonic/gin"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
)

type APIEventPQMatchScore struct {
	// uuid
	EventID string `boil:"event_id" json:"event_id" toml:"event_id" yaml:"event_id"`

	// character varying
	ProfileQuestionID string `boil:"profile_question_id" json:"profile_question_id" toml:"profile_question_id" yaml:"profile_question_id"`

	// integer

	RatingAvg *int `boil:"rating_avg" json:"rating_avg,omitempty" toml:"rating_avg" yaml:"rating_avg,omitempty"`

	// double precision

	NumAvg *float64 `boil:"num_avg" json:"num_avg,omitempty" toml:"num_avg" yaml:"num_avg,omitempty"`
}

type GetEventPQMatchScoresResponse struct {
	EventPQMatchScores models.EventPQMatchScoreSlice `json:"event_pq_match_scores"`
	Total              int64                         `json:"total"`
	NextOffset         int64                         `json:"next_offset"`
}

type APIGetEventPQMatchScoresResponse struct {
	EventPQMatchScores []APIEventPQMatchScore `json:"event_pq_match_scores"`
	Total              int64                  `json:"total"`
	NextOffset         int64                  `json:"next_offset"`
}

// GetEventPQMatchScoreByID godoc
// @Summary Gets a single EventPQMatchScore entity by their id
// @Produce json
// @Success 200 {object} APIGetEventPQMatchScoresResponse
// @Param id path string true "EventPQMatchScore id"
// @Router /crud/eventPQMatchScores/:id [get]
func (*GeneratedCrudController) GetEventPQMatchScoreByID(c *gin.Context) {
	id := c.Param("id")

	if id == "" {
		api.NewAPIError("invalid-id", http.StatusBadRequest, "The provided id was invalid").Respond(c)
		return
	}

	EventPQMatchScore, err := models.EventPQMatchScores(qm.Where("id = ?", id)).OneG(c.Request.Context())
	if err != nil {
		api.APIErrorFromErr(err).Respond(c)
		return
	}

	c.JSON(http.StatusOK, EventPQMatchScore)
}

// GetEventPQMatchScores godoc
// @Summary Gets a list for all entities of the EventPQMatchScore type
// @Produce json
// @Success 200 {object} APIEventPQMatchScore
// @Param sort.event_id query string false "Sort by event_id. Value should be ASC or DESC. eg: ?sort.created_at=DESC"
// @Param sort.profile_question_id query string false "Sort by profile_question_id. Value should be ASC or DESC. eg: ?sort.created_at=DESC"
// @Param sort.rating_avg query string false "Sort by rating_avg. Value should be ASC or DESC. eg: ?sort.created_at=DESC"
// @Param sort.num_avg query string false "Sort by num_avg. Value should be ASC or DESC. eg: ?sort.created_at=DESC"
// @Router /crud/eventPQMatchScores [get]
func (*GeneratedCrudController) GetEventPQMatchScores(c *gin.Context) {
	queryMods := []qm.QueryMod{}

	var orderBy []string

	for q, v := range c.Request.URL.Query() {
		sortDirection := "ASC"

		if v[0] == "DESC" || v[0] == "desc" {
			sortDirection = "DESC"
		}

		switch q {
		case "sort.event_id":
			orderBy = append(orderBy, "event_id "+sortDirection)
		case "event_id.eq":
			queryMods = append(queryMods, qm.Where("event_id = ?", v[0]))
		case "event_id.null":
			if v[0] == "true" {
				queryMods = append(queryMods, qm.Where("event_id IS NULL"))
			} else {
				queryMods = append(queryMods, qm.Where("event_id IS NOT NULL"))
			}

		case "sort.profile_question_id":
			orderBy = append(orderBy, "profile_question_id "+sortDirection)
		case "profile_question_id.eq":
			queryMods = append(queryMods, qm.Where("profile_question_id = ?", v[0]))
		case "profile_question_id.null":
			if v[0] == "true" {
				queryMods = append(queryMods, qm.Where("profile_question_id IS NULL"))
			} else {
				queryMods = append(queryMods, qm.Where("profile_question_id IS NOT NULL"))
			}

		case "profile_question_id.cont":
			profile_question_idSearchString := fmt.Sprintf("%%%s%%", strings.ReplaceAll(v[0], "%", "\\%"))
			queryMods = append(queryMods, qm.Where("profile_question_id ILIKE ?", profile_question_idSearchString))

		case "sort.rating_avg":
			orderBy = append(orderBy, "rating_avg "+sortDirection)
		case "rating_avg.eq":
			queryMods = append(queryMods, qm.Where("rating_avg = ?", v[0]))
		case "rating_avg.null":
			if v[0] == "true" {
				queryMods = append(queryMods, qm.Where("rating_avg IS NULL"))
			} else {
				queryMods = append(queryMods, qm.Where("rating_avg IS NOT NULL"))
			}

		case "rating_avg.gt":
			queryMods = append(queryMods, qm.Where("rating_avg > ?", v[0]))
		case "rating_avg.lt":
			queryMods = append(queryMods, qm.Where("rating_avg < ?", v[0]))
		case "rating_avg.gte":
			queryMods = append(queryMods, qm.Where("rating_avg >= ?", v[0]))
		case "rating_avg.lte":
			queryMods = append(queryMods, qm.Where("rating_avg <= ?", v[0]))

		case "sort.num_avg":
			orderBy = append(orderBy, "num_avg "+sortDirection)
		case "num_avg.eq":
			queryMods = append(queryMods, qm.Where("num_avg = ?", v[0]))
		case "num_avg.null":
			if v[0] == "true" {
				queryMods = append(queryMods, qm.Where("num_avg IS NULL"))
			} else {
				queryMods = append(queryMods, qm.Where("num_avg IS NOT NULL"))
			}

		case "num_avg.gt":
			queryMods = append(queryMods, qm.Where("num_avg > ?", v[0]))
		case "num_avg.lt":
			queryMods = append(queryMods, qm.Where("num_avg < ?", v[0]))
		case "num_avg.gte":
			queryMods = append(queryMods, qm.Where("num_avg >= ?", v[0]))
		case "num_avg.lte":
			queryMods = append(queryMods, qm.Where("num_avg <= ?", v[0]))

		}
	}

	count, err := models.EventPQMatchScores(queryMods...).CountG(c.Request.Context())
	if err != nil {
		api.APIErrorFromErr(err).Respond(c)
		return
	}

	limit, offset := api.ExtractLimitOffset(c)

	queryMods = append(queryMods, qm.Limit(limit), qm.Offset(offset))

	if len(orderBy) > 0 {
		queryMods = append(queryMods, qm.OrderBy(strings.Join(orderBy, ", ")))
	}

	eventPQMatchScores, err := models.EventPQMatchScores(queryMods...).AllG(c.Request.Context())
	if err != nil {
		api.APIErrorFromErr(err).Respond(c)
		return
	}

	if eventPQMatchScores == nil {
		eventPQMatchScores = models.EventPQMatchScoreSlice{}
	}

	c.JSON(http.StatusOK, GetEventPQMatchScoresResponse{
		EventPQMatchScores: eventPQMatchScores,
		Total:              count,
		NextOffset:         int64(offset + limit),
	})
}
