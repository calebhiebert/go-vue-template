// Code generated by SQLBoiler 4.6.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package modelcrud

import (
	"fmt"
	"net/http"
	"strings"
	"time"

	"github.com/calebhiebert/go-vue-template/api"
	"github.com/calebhiebert/go-vue-template/models"
	"github.com/gin-gonic/gin"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
)

type APIAccessLog struct {
	// uuid
	ID string `boil:"id" json:"id" toml:"id" yaml:"id"`

	// character varying
	Path string `boil:"path" json:"path" toml:"path" yaml:"path"`

	// text

	RequestBody *string `boil:"request_body" json:"request_body,omitempty" toml:"request_body" yaml:"request_body,omitempty"`

	// jsonb

	RequestHeaders map[string]interface{} `boil:"request_headers" json:"request_headers,omitempty" toml:"request_headers" yaml:"request_headers,omitempty"`

	// jsonb

	ResponseBody map[string]interface{} `boil:"response_body" json:"response_body" toml:"response_body" yaml:"response_body"`

	// jsonb

	ResponseHeaders map[string]interface{} `boil:"response_headers" json:"response_headers" toml:"response_headers" yaml:"response_headers"`

	// integer
	ResponseCode int `boil:"response_code" json:"response_code" toml:"response_code" yaml:"response_code"`

	// integer
	ProcessingDuration int `boil:"processing_duration" json:"processing_duration" toml:"processing_duration" yaml:"processing_duration"`

	// character varying
	RequestMethod string `boil:"request_method" json:"request_method" toml:"request_method" yaml:"request_method"`

	// uuid

	UserID *string `boil:"user_id" json:"user_id,omitempty" toml:"user_id" yaml:"user_id,omitempty"`

	// character varying
	IPAddress string `boil:"ip_address" json:"ip_address" toml:"ip_address" yaml:"ip_address"`

	// timestamp without time zone

	CreatedAt *time.Time `boil:"created_at" json:"created_at,omitempty" toml:"created_at" yaml:"created_at,omitempty"`
}

type GetAccessLogsResponse struct {
	AccessLogs models.AccessLogSlice `json:"access_logs"`
	Total      int64                 `json:"total"`
	NextOffset int64                 `json:"next_offset"`
}

type APIGetAccessLogsResponse struct {
	AccessLogs []APIAccessLog `json:"access_logs"`
	Total      int64          `json:"total"`
	NextOffset int64          `json:"next_offset"`
}

// GetAccessLogByID godoc
// @Summary Gets a single AccessLog entity by their id
// @Produce json
// @Success 200 {object} APIGetAccessLogsResponse
// @Param id path string true "AccessLog id"
// @Router /crud/accessLogs/:id [get]
func (*GeneratedCrudController) GetAccessLogByID(c *gin.Context) {
	id := c.Param("id")

	if id == "" {
		api.NewAPIError("invalid-id", http.StatusBadRequest, "The provided id was invalid").Respond(c)
		return
	}

	AccessLog, err := models.AccessLogs(qm.Where("id = ?", id)).OneG(c.Request.Context())
	if err != nil {
		api.APIErrorFromErr(err).Respond(c)
		return
	}

	c.JSON(http.StatusOK, AccessLog)
}

// GetAccessLogs godoc
// @Summary Gets a list for all entities of the AccessLog type
// @Produce json
// @Success 200 {object} APIAccessLog
// @Param sort.id query string false "Sort by id. Value should be ASC or DESC. eg: ?sort.created_at=DESC"
// @Param sort.path query string false "Sort by path. Value should be ASC or DESC. eg: ?sort.created_at=DESC"
// @Param sort.request_body query string false "Sort by request_body. Value should be ASC or DESC. eg: ?sort.created_at=DESC"
// @Param sort.request_headers query string false "Sort by request_headers. Value should be ASC or DESC. eg: ?sort.created_at=DESC"
// @Param sort.response_body query string false "Sort by response_body. Value should be ASC or DESC. eg: ?sort.created_at=DESC"
// @Param sort.response_headers query string false "Sort by response_headers. Value should be ASC or DESC. eg: ?sort.created_at=DESC"
// @Param sort.response_code query string false "Sort by response_code. Value should be ASC or DESC. eg: ?sort.created_at=DESC"
// @Param sort.processing_duration query string false "Sort by processing_duration. Value should be ASC or DESC. eg: ?sort.created_at=DESC"
// @Param sort.request_method query string false "Sort by request_method. Value should be ASC or DESC. eg: ?sort.created_at=DESC"
// @Param sort.user_id query string false "Sort by user_id. Value should be ASC or DESC. eg: ?sort.created_at=DESC"
// @Param sort.ip_address query string false "Sort by ip_address. Value should be ASC or DESC. eg: ?sort.created_at=DESC"
// @Param sort.created_at query string false "Sort by created_at. Value should be ASC or DESC. eg: ?sort.created_at=DESC"
// @Router /crud/accessLogs [get]
func (*GeneratedCrudController) GetAccessLogs(c *gin.Context) {
	queryMods := []qm.QueryMod{}

	var orderBy []string

	for q, v := range c.Request.URL.Query() {
		sortDirection := "ASC"

		if v[0] == "DESC" || v[0] == "desc" {
			sortDirection = "DESC"
		}

		switch q {
		case "sort.id":
			orderBy = append(orderBy, "id "+sortDirection)
		case "id.eq":
			queryMods = append(queryMods, qm.Where("id = ?", v[0]))

		case "sort.path":
			orderBy = append(orderBy, "path "+sortDirection)
		case "path.eq":
			queryMods = append(queryMods, qm.Where("path = ?", v[0]))

		case "path.cont":
			pathSearchString := fmt.Sprintf("%%%s%%", strings.ReplaceAll(v[0], "%", "\\%"))
			queryMods = append(queryMods, qm.Where("path ILIKE ?", pathSearchString))

		case "sort.request_body":
			orderBy = append(orderBy, "request_body "+sortDirection)
		case "request_body.eq":
			queryMods = append(queryMods, qm.Where("request_body = ?", v[0]))

		case "request_body.cont":
			request_bodySearchString := fmt.Sprintf("%%%s%%", strings.ReplaceAll(v[0], "%", "\\%"))
			queryMods = append(queryMods, qm.Where("request_body ILIKE ?", request_bodySearchString))

		case "sort.request_headers":
			orderBy = append(orderBy, "request_headers "+sortDirection)
		case "request_headers.eq":
			queryMods = append(queryMods, qm.Where("request_headers = ?", v[0]))

		case "sort.response_body":
			orderBy = append(orderBy, "response_body "+sortDirection)
		case "response_body.eq":
			queryMods = append(queryMods, qm.Where("response_body = ?", v[0]))

		case "sort.response_headers":
			orderBy = append(orderBy, "response_headers "+sortDirection)
		case "response_headers.eq":
			queryMods = append(queryMods, qm.Where("response_headers = ?", v[0]))

		case "sort.response_code":
			orderBy = append(orderBy, "response_code "+sortDirection)
		case "response_code.eq":
			queryMods = append(queryMods, qm.Where("response_code = ?", v[0]))

		case "response_code.gt":
			queryMods = append(queryMods, qm.Where("response_code > ?", v[0]))
		case "response_code.lt":
			queryMods = append(queryMods, qm.Where("response_code < ?", v[0]))
		case "response_code.gte":
			queryMods = append(queryMods, qm.Where("response_code >= ?", v[0]))
		case "response_code.lte":
			queryMods = append(queryMods, qm.Where("response_code <= ?", v[0]))

		case "sort.processing_duration":
			orderBy = append(orderBy, "processing_duration "+sortDirection)
		case "processing_duration.eq":
			queryMods = append(queryMods, qm.Where("processing_duration = ?", v[0]))

		case "processing_duration.gt":
			queryMods = append(queryMods, qm.Where("processing_duration > ?", v[0]))
		case "processing_duration.lt":
			queryMods = append(queryMods, qm.Where("processing_duration < ?", v[0]))
		case "processing_duration.gte":
			queryMods = append(queryMods, qm.Where("processing_duration >= ?", v[0]))
		case "processing_duration.lte":
			queryMods = append(queryMods, qm.Where("processing_duration <= ?", v[0]))

		case "sort.request_method":
			orderBy = append(orderBy, "request_method "+sortDirection)
		case "request_method.eq":
			queryMods = append(queryMods, qm.Where("request_method = ?", v[0]))

		case "request_method.cont":
			request_methodSearchString := fmt.Sprintf("%%%s%%", strings.ReplaceAll(v[0], "%", "\\%"))
			queryMods = append(queryMods, qm.Where("request_method ILIKE ?", request_methodSearchString))

		case "sort.user_id":
			orderBy = append(orderBy, "user_id "+sortDirection)
		case "user_id.eq":
			queryMods = append(queryMods, qm.Where("user_id = ?", v[0]))

		case "sort.ip_address":
			orderBy = append(orderBy, "ip_address "+sortDirection)
		case "ip_address.eq":
			queryMods = append(queryMods, qm.Where("ip_address = ?", v[0]))

		case "ip_address.cont":
			ip_addressSearchString := fmt.Sprintf("%%%s%%", strings.ReplaceAll(v[0], "%", "\\%"))
			queryMods = append(queryMods, qm.Where("ip_address ILIKE ?", ip_addressSearchString))

		case "sort.created_at":
			orderBy = append(orderBy, "created_at "+sortDirection)
		case "created_at.eq":
			queryMods = append(queryMods, qm.Where("created_at = ?", v[0]))

		case "created_at.gt":
			queryMods = append(queryMods, qm.Where("created_at > ?", v[0]))
		case "created_at.lt":
			queryMods = append(queryMods, qm.Where("created_at < ?", v[0]))
		case "created_at.gte":
			queryMods = append(queryMods, qm.Where("created_at >= ?", v[0]))
		case "created_at.lte":
			queryMods = append(queryMods, qm.Where("created_at <= ?", v[0]))

		}
	}

	count, err := models.AccessLogs(queryMods...).CountG(c.Request.Context())
	if err != nil {
		api.APIErrorFromErr(err).Respond(c)
		return
	}

	limit, offset := api.ExtractLimitOffset(c)

	queryMods = append(queryMods, qm.Limit(limit), qm.Offset(offset))

	if len(orderBy) > 0 {
		queryMods = append(queryMods, qm.OrderBy(strings.Join(orderBy, ", ")))
	} else {
		queryMods = append(queryMods, qm.OrderBy("created_at DESC"))
	}

	accessLogs, err := models.AccessLogs(queryMods...).AllG(c.Request.Context())
	if err != nil {
		api.APIErrorFromErr(err).Respond(c)
		return
	}

	if accessLogs == nil {
		accessLogs = models.AccessLogSlice{}
	}

	c.JSON(http.StatusOK, GetAccessLogsResponse{
		AccessLogs: accessLogs,
		Total:      count,
		NextOffset: int64(offset + limit),
	})
}
