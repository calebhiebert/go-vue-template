// Code generated by SQLBoiler 4.6.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package modelcrud

import (
	"fmt"
	"net/http"
	"strings"
	"time"

	"github.com/calebhiebert/go-vue-template/api"
	"github.com/calebhiebert/go-vue-template/models"
	"github.com/gin-gonic/gin"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
)

type APIJob struct {
	// uuid
	ID string `boil:"id" json:"id" toml:"id" yaml:"id"`

	// character varying

	Type *string `boil:"type" json:"type,omitempty" toml:"type" yaml:"type,omitempty"`

	// integer
	Priority int `boil:"priority" json:"priority" toml:"priority" yaml:"priority"`

	// character varying

	Source *string `boil:"source" json:"source,omitempty" toml:"source" yaml:"source,omitempty"`

	// jsonb

	Data map[string]interface{} `boil:"data" json:"data,omitempty" toml:"data" yaml:"data,omitempty"`

	// timestamp without time zone

	RunAt *time.Time `boil:"run_at" json:"run_at,omitempty" toml:"run_at" yaml:"run_at,omitempty"`

	// jsonb

	FailureData map[string]interface{} `boil:"failure_data" json:"failure_data,omitempty" toml:"failure_data" yaml:"failure_data,omitempty"`

	// integer
	MaxRetries int `boil:"max_retries" json:"max_retries" toml:"max_retries" yaml:"max_retries"`

	// integer

	RetryCount *int `boil:"retry_count" json:"retry_count,omitempty" toml:"retry_count" yaml:"retry_count,omitempty"`

	// character varying
	Status string `boil:"status" json:"status" toml:"status" yaml:"status"`

	// timestamp without time zone

	FinishedAt *time.Time `boil:"finished_at" json:"finished_at,omitempty" toml:"finished_at" yaml:"finished_at,omitempty"`

	// timestamp without time zone

	CreatedAt *time.Time `boil:"created_at" json:"created_at,omitempty" toml:"created_at" yaml:"created_at,omitempty"`
}

type GetJobsResponse struct {
	Jobs       models.JobSlice `json:"jobs"`
	Total      int64           `json:"total"`
	NextOffset int64           `json:"next_offset"`
}

type APIGetJobsResponse struct {
	Jobs       []APIJob `json:"jobs"`
	Total      int64    `json:"total"`
	NextOffset int64    `json:"next_offset"`
}

// GetJobByID godoc
// @Summary Gets a single Job entity by their id
// @Produce json
// @Success 200 {object} APIGetJobsResponse
// @Param id path string true "Job id"
// @Router /crud/jobs/:id [get]
func (*GeneratedCrudController) GetJobByID(c *gin.Context) {
	id := c.Param("id")

	if id == "" {
		api.NewAPIError("invalid-id", http.StatusBadRequest, "The provided id was invalid").Respond(c)
		return
	}

	Job, err := models.Jobs(qm.Where("id = ?", id)).OneG(c.Request.Context())
	if err != nil {
		api.APIErrorFromErr(err).Respond(c)
		return
	}

	c.JSON(http.StatusOK, Job)
}

// GetJobs godoc
// @Summary Gets a list for all entities of the Job type
// @Produce json
// @Success 200 {object} APIJob
// @Param sort.id query string false "Sort by id. Value should be ASC or DESC. eg: ?sort.created_at=DESC"
// @Param sort.type query string false "Sort by type. Value should be ASC or DESC. eg: ?sort.created_at=DESC"
// @Param sort.priority query string false "Sort by priority. Value should be ASC or DESC. eg: ?sort.created_at=DESC"
// @Param sort.source query string false "Sort by source. Value should be ASC or DESC. eg: ?sort.created_at=DESC"
// @Param sort.data query string false "Sort by data. Value should be ASC or DESC. eg: ?sort.created_at=DESC"
// @Param sort.run_at query string false "Sort by run_at. Value should be ASC or DESC. eg: ?sort.created_at=DESC"
// @Param sort.failure_data query string false "Sort by failure_data. Value should be ASC or DESC. eg: ?sort.created_at=DESC"
// @Param sort.max_retries query string false "Sort by max_retries. Value should be ASC or DESC. eg: ?sort.created_at=DESC"
// @Param sort.retry_count query string false "Sort by retry_count. Value should be ASC or DESC. eg: ?sort.created_at=DESC"
// @Param sort.status query string false "Sort by status. Value should be ASC or DESC. eg: ?sort.created_at=DESC"
// @Param sort.finished_at query string false "Sort by finished_at. Value should be ASC or DESC. eg: ?sort.created_at=DESC"
// @Param sort.created_at query string false "Sort by created_at. Value should be ASC or DESC. eg: ?sort.created_at=DESC"
// @Router /crud/jobs [get]
func (*GeneratedCrudController) GetJobs(c *gin.Context) {
	queryMods := []qm.QueryMod{}

	var orderBy []string

	for q, v := range c.Request.URL.Query() {
		sortDirection := "ASC"

		if v[0] == "DESC" || v[0] == "desc" {
			sortDirection = "DESC"
		}

		switch q {
		case "sort.id":
			orderBy = append(orderBy, "id "+sortDirection)
		case "id.eq":
			queryMods = append(queryMods, qm.Where("id = ?", v[0]))
		case "id.null":
			if v[0] == "true" {
				queryMods = append(queryMods, qm.Where("id IS NULL"))
			} else {
				queryMods = append(queryMods, qm.Where("id IS NOT NULL"))
			}

		case "sort.type":
			orderBy = append(orderBy, "type "+sortDirection)
		case "type.eq":
			queryMods = append(queryMods, qm.Where("type = ?", v[0]))
		case "type.null":
			if v[0] == "true" {
				queryMods = append(queryMods, qm.Where("type IS NULL"))
			} else {
				queryMods = append(queryMods, qm.Where("type IS NOT NULL"))
			}

		case "type.cont":
			typeSearchString := fmt.Sprintf("%%%s%%", strings.ReplaceAll(v[0], "%", "\\%"))
			queryMods = append(queryMods, qm.Where("type ILIKE ?", typeSearchString))

		case "sort.priority":
			orderBy = append(orderBy, "priority "+sortDirection)
		case "priority.eq":
			queryMods = append(queryMods, qm.Where("priority = ?", v[0]))
		case "priority.null":
			if v[0] == "true" {
				queryMods = append(queryMods, qm.Where("priority IS NULL"))
			} else {
				queryMods = append(queryMods, qm.Where("priority IS NOT NULL"))
			}

		case "priority.gt":
			queryMods = append(queryMods, qm.Where("priority > ?", v[0]))
		case "priority.lt":
			queryMods = append(queryMods, qm.Where("priority < ?", v[0]))
		case "priority.gte":
			queryMods = append(queryMods, qm.Where("priority >= ?", v[0]))
		case "priority.lte":
			queryMods = append(queryMods, qm.Where("priority <= ?", v[0]))

		case "sort.source":
			orderBy = append(orderBy, "source "+sortDirection)
		case "source.eq":
			queryMods = append(queryMods, qm.Where("source = ?", v[0]))
		case "source.null":
			if v[0] == "true" {
				queryMods = append(queryMods, qm.Where("source IS NULL"))
			} else {
				queryMods = append(queryMods, qm.Where("source IS NOT NULL"))
			}

		case "source.cont":
			sourceSearchString := fmt.Sprintf("%%%s%%", strings.ReplaceAll(v[0], "%", "\\%"))
			queryMods = append(queryMods, qm.Where("source ILIKE ?", sourceSearchString))

		case "sort.data":
			orderBy = append(orderBy, "data "+sortDirection)
		case "data.eq":
			queryMods = append(queryMods, qm.Where("data = ?", v[0]))
		case "data.null":
			if v[0] == "true" {
				queryMods = append(queryMods, qm.Where("data IS NULL"))
			} else {
				queryMods = append(queryMods, qm.Where("data IS NOT NULL"))
			}

		case "sort.run_at":
			orderBy = append(orderBy, "run_at "+sortDirection)
		case "run_at.eq":
			queryMods = append(queryMods, qm.Where("run_at = ?", v[0]))
		case "run_at.null":
			if v[0] == "true" {
				queryMods = append(queryMods, qm.Where("run_at IS NULL"))
			} else {
				queryMods = append(queryMods, qm.Where("run_at IS NOT NULL"))
			}

		case "run_at.gt":
			queryMods = append(queryMods, qm.Where("run_at > ?", v[0]))
		case "run_at.lt":
			queryMods = append(queryMods, qm.Where("run_at < ?", v[0]))
		case "run_at.gte":
			queryMods = append(queryMods, qm.Where("run_at >= ?", v[0]))
		case "run_at.lte":
			queryMods = append(queryMods, qm.Where("run_at <= ?", v[0]))

		case "sort.failure_data":
			orderBy = append(orderBy, "failure_data "+sortDirection)
		case "failure_data.eq":
			queryMods = append(queryMods, qm.Where("failure_data = ?", v[0]))
		case "failure_data.null":
			if v[0] == "true" {
				queryMods = append(queryMods, qm.Where("failure_data IS NULL"))
			} else {
				queryMods = append(queryMods, qm.Where("failure_data IS NOT NULL"))
			}

		case "sort.max_retries":
			orderBy = append(orderBy, "max_retries "+sortDirection)
		case "max_retries.eq":
			queryMods = append(queryMods, qm.Where("max_retries = ?", v[0]))
		case "max_retries.null":
			if v[0] == "true" {
				queryMods = append(queryMods, qm.Where("max_retries IS NULL"))
			} else {
				queryMods = append(queryMods, qm.Where("max_retries IS NOT NULL"))
			}

		case "max_retries.gt":
			queryMods = append(queryMods, qm.Where("max_retries > ?", v[0]))
		case "max_retries.lt":
			queryMods = append(queryMods, qm.Where("max_retries < ?", v[0]))
		case "max_retries.gte":
			queryMods = append(queryMods, qm.Where("max_retries >= ?", v[0]))
		case "max_retries.lte":
			queryMods = append(queryMods, qm.Where("max_retries <= ?", v[0]))

		case "sort.retry_count":
			orderBy = append(orderBy, "retry_count "+sortDirection)
		case "retry_count.eq":
			queryMods = append(queryMods, qm.Where("retry_count = ?", v[0]))
		case "retry_count.null":
			if v[0] == "true" {
				queryMods = append(queryMods, qm.Where("retry_count IS NULL"))
			} else {
				queryMods = append(queryMods, qm.Where("retry_count IS NOT NULL"))
			}

		case "retry_count.gt":
			queryMods = append(queryMods, qm.Where("retry_count > ?", v[0]))
		case "retry_count.lt":
			queryMods = append(queryMods, qm.Where("retry_count < ?", v[0]))
		case "retry_count.gte":
			queryMods = append(queryMods, qm.Where("retry_count >= ?", v[0]))
		case "retry_count.lte":
			queryMods = append(queryMods, qm.Where("retry_count <= ?", v[0]))

		case "sort.status":
			orderBy = append(orderBy, "status "+sortDirection)
		case "status.eq":
			queryMods = append(queryMods, qm.Where("status = ?", v[0]))
		case "status.null":
			if v[0] == "true" {
				queryMods = append(queryMods, qm.Where("status IS NULL"))
			} else {
				queryMods = append(queryMods, qm.Where("status IS NOT NULL"))
			}

		case "status.cont":
			statusSearchString := fmt.Sprintf("%%%s%%", strings.ReplaceAll(v[0], "%", "\\%"))
			queryMods = append(queryMods, qm.Where("status ILIKE ?", statusSearchString))

		case "sort.finished_at":
			orderBy = append(orderBy, "finished_at "+sortDirection)
		case "finished_at.eq":
			queryMods = append(queryMods, qm.Where("finished_at = ?", v[0]))
		case "finished_at.null":
			if v[0] == "true" {
				queryMods = append(queryMods, qm.Where("finished_at IS NULL"))
			} else {
				queryMods = append(queryMods, qm.Where("finished_at IS NOT NULL"))
			}

		case "finished_at.gt":
			queryMods = append(queryMods, qm.Where("finished_at > ?", v[0]))
		case "finished_at.lt":
			queryMods = append(queryMods, qm.Where("finished_at < ?", v[0]))
		case "finished_at.gte":
			queryMods = append(queryMods, qm.Where("finished_at >= ?", v[0]))
		case "finished_at.lte":
			queryMods = append(queryMods, qm.Where("finished_at <= ?", v[0]))

		case "sort.created_at":
			orderBy = append(orderBy, "created_at "+sortDirection)
		case "created_at.eq":
			queryMods = append(queryMods, qm.Where("created_at = ?", v[0]))
		case "created_at.null":
			if v[0] == "true" {
				queryMods = append(queryMods, qm.Where("created_at IS NULL"))
			} else {
				queryMods = append(queryMods, qm.Where("created_at IS NOT NULL"))
			}

		case "created_at.gt":
			queryMods = append(queryMods, qm.Where("created_at > ?", v[0]))
		case "created_at.lt":
			queryMods = append(queryMods, qm.Where("created_at < ?", v[0]))
		case "created_at.gte":
			queryMods = append(queryMods, qm.Where("created_at >= ?", v[0]))
		case "created_at.lte":
			queryMods = append(queryMods, qm.Where("created_at <= ?", v[0]))

		}
	}

	count, err := models.Jobs(queryMods...).CountG(c.Request.Context())
	if err != nil {
		api.APIErrorFromErr(err).Respond(c)
		return
	}

	limit, offset := api.ExtractLimitOffset(c)

	queryMods = append(queryMods, qm.Limit(limit), qm.Offset(offset))

	if len(orderBy) > 0 {
		queryMods = append(queryMods, qm.OrderBy(strings.Join(orderBy, ", ")))
	} else {
		queryMods = append(queryMods, qm.OrderBy("created_at DESC"))
	}

	jobs, err := models.Jobs(queryMods...).AllG(c.Request.Context())
	if err != nil {
		api.APIErrorFromErr(err).Respond(c)
		return
	}

	if jobs == nil {
		jobs = models.JobSlice{}
	}

	c.JSON(http.StatusOK, GetJobsResponse{
		Jobs:       jobs,
		Total:      count,
		NextOffset: int64(offset + limit),
	})
}
